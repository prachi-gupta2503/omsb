"use strict";
/**
 * SPDX-FileCopyrightText: Â© 2017 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const project_1 = __importDefault(require("liferay-npm-build-tools-common/lib/project"));
function default_1({ log, pkg }) {
    if (!pkg.isRoot) {
        return;
    }
    const sourcemapFiles = findSourceMaps(project_1.default.dir.join(project_1.default.buildDir));
    if (!sourcemapFiles.length) {
        return;
    }
    for (const sourcemapFile of sourcemapFiles) {
        try {
            const sourcemap = JSON.parse(fs_1.default.readFileSync(sourcemapFile.asNative, 'utf-8'));
            const jsFileName = sourcemapFile
                .basename()
                .asNative.replace(/\.map$/, '');
            sourcemap.sources = [jsFileName];
            fs_1.default.writeFileSync(sourcemapFile.asNative, JSON.stringify(sourcemap));
        }
        catch (error) {
            log.warn('tweak-sourcemaps', `Invalid source map file found: ${sourcemapFile.asNative}`, error);
        }
    }
    log.info('tweak-sourcemaps', 'Tweaked', sourcemapFiles.length, 'source maps');
}
exports.default = default_1;
function findSourceMaps(dir) {
    const files = [];
    for (const dirent of fs_1.default.readdirSync(dir.asNative, { withFileTypes: true })) {
        const item = dirent.name;
        if (item === 'node_modules') {
            continue;
        }
        if (dirent.isDirectory()) {
            for (const child of findSourceMaps(dir.join(item))) {
                files.push(child);
            }
            continue;
        }
        if (!item.endsWith('.map')) {
            continue;
        }
        files.push(dir.join(item));
    }
    return files;
}
