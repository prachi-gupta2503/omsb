"use strict";
/**
 * SPDX-FileCopyrightText: Â© 2017 Liferay, Inc. <https://liferay.com>
 * SPDX-License-Identifier: LGPL-3.0-or-later
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = __importStar(require("fs"));
const globby = __importStar(require("globby"));
const file_path_1 = __importDefault(require("liferay-npm-build-tools-common/lib/file-path"));
const mod = __importStar(require("liferay-npm-build-tools-common/lib/modules"));
const ns = __importStar(require("liferay-npm-build-tools-common/lib/namespace"));
const read_json_sync_1 = __importDefault(require("read-json-sync"));
const resolve_1 = __importDefault(require("resolve"));
/**
 * @return {void}
 */
function default_1({ config, log, pkg, source }, { pkgJson }) {
    const defineCall = (config.defineCall || 'Liferay.Loader.define') + '(';
    pkgJson.dependencies = pkgJson.dependencies || {};
    const injectedDeps = {};
    const failedDeps = {};
    globby
        .sync([`${pkg.dir.asPosix}/**/*.js`])
        .map((posixPath) => new file_path_1.default(posixPath, { posix: true }))
        .forEach((file) => {
        const code = fs.readFileSync(file.asNative);
        const defineCallOffset = code.indexOf(defineCall);
        if (defineCallOffset !== -1) {
            const funOffset = code.indexOf(')', defineCallOffset);
            let defineCallLine;
            if (code instanceof Buffer) {
                defineCallLine = code.toString('utf8', defineCallOffset + defineCall.length, funOffset);
            }
            else {
                defineCallLine = code.substring(defineCallOffset + defineCall.length, funOffset);
            }
            defineCallLine = defineCallLine.replace(/\n/g, ' ');
            defineCallLine = removeModuleName(defineCallLine);
            defineCallLine = defineCallLine.trim();
            const deps = extractDependencies(defineCallLine);
            processModuleDependencies(pkgJson, deps, source.pkg.dir, injectedDeps, failedDeps);
        }
    });
    Object.keys(injectedDeps).forEach((dep) => {
        log.info('inject-peer-dependencies', 'Injected dependency', `${dep}@${injectedDeps[dep]}`);
    });
    Object.keys(failedDeps).forEach((dep) => {
        log.warn('inject-peer-dependencies', 'Failed to resolve dependency', dep, 'with error:', failedDeps[dep]);
    });
}
exports.default = default_1;
/**
 * Process dependencies of a file.
 * @param {Object} pkgJson processed module's package.json
 * @param {Array} deps array of dependencies as passed to define() call
 * @param {FilePath} resolveDir path from where to resolve dependencies
 * @param {Object} injectedDeps a hash to fill with resolved dependencies
 * @param {Object} failedDeps a hash to fill with failed dependencies
 * @return {void}
 */
function processModuleDependencies(pkgJson, deps, resolveDir, injectedDeps, failedDeps) {
    deps.forEach((dep) => {
        if (!mod.isExternalDependency(dep) || mod.isNodeCoreModule(dep)) {
            return;
        }
        const { pkgName, scope } = mod.splitModuleName(dep);
        const scopedPkgName = mod.joinModuleName(scope, pkgName);
        if (!pkgJson.dependencies[scopedPkgName]) {
            const srcPkgName = ns.removeNamespace(scopedPkgName);
            try {
                const resolvedPkgJsonPath = resolve_1.default.sync(`${srcPkgName}/package.json`, {
                    basedir: resolveDir.asNative,
                });
                const resolvedPkgJson = read_json_sync_1.default(resolvedPkgJsonPath);
                pkgJson.dependencies[scopedPkgName] = resolvedPkgJson.version;
                injectedDeps[scopedPkgName] = resolvedPkgJson.version;
            }
            catch (err) {
                failedDeps[dep] = err;
            }
        }
    });
}
/**
 * Removes module name argument from a define call
 * @param  {String} line the line containing a define call
 * @return {String} the rest of the line without module name
 */
function removeModuleName(line) {
    let inString = false;
    for (let i = 0; i < line.length; i++) {
        if (inString) {
            if (line[i] === inString) {
                inString = false;
            }
        }
        else {
            switch (line[i]) {
                case "'":
                case '"':
                    inString = line[i];
                    break;
                case ',':
                    return line.substr(i + 1);
                default:
                // Keep scanning.
            }
        }
    }
    return '';
}
/**
 * Extracts dependencies argument from a define call
 * @param  {String} line the line containing a define call starting at the
 * 							dependencies argument
 * @return {Array} an array with
 */
function extractDependencies(line) {
    const indexOfClose = line.indexOf(']');
    if (!line.startsWith('[') || indexOfClose === -1) {
        return [];
    }
    return line
        .substring(1, indexOfClose)
        .split(',')
        .map((dep) => dep.trim())
        .map((dep) => dep.replace(/['"]/g, ''));
}
